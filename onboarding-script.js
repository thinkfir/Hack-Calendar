// Global application state for onboarding process
const app = {
    hackathonSettings: {
        name: '',
        startDate: null,
        duration: null // in hours
    },
    teamMembers: [],
    allTasks: [], // Tasks generated by AI during onboarding
    projectIdea: '',
    chatHistory: { // Chat history specific to onboarding AI step
        onboardingAI: []
    }
};

// Element references (cached for performance) - specific to onboarding pages
const elements = {};

// Initialize application on DOM content loaded
document.addEventListener('DOMContentLoaded', () => {
    // Cache common DOM elements used across onboarding pages
    elements.onboardingContainer = document.getElementById('onboarding-container');
    elements.onboardingVisualSidebar = document.getElementById('onboarding-visual-sidebar');
    elements.onboardingSteps = document.querySelectorAll('.onboarding-step'); // All 3 steps
    elements.onboardingContentArea = document.getElementById('onboarding-content-area');

    // Modals
    elements.customMessageModal = document.getElementById('custom-message-modal');
    elements.customMessageTitle = document.getElementById('custom-message-title');
    elements.customMessageBody = document.getElementById('custom-message-body');
    elements.customMessageConfirmBtn = document.getElementById('custom-message-confirm-btn');
    elements.customMessageCancelBtn = document.getElementById('custom-message-cancel-btn');
    elements.customMessageOkBtn = document.getElementById('custom-message-ok-btn');

    // Determine current step based on the loaded HTML file
    const path = window.location.pathname;
    if (path.includes('onboarding-team.html')) {
        app.onboardingStep = 1;
        // Elements specific to Team Members page
        elements.onboardingTeamList = document.getElementById('onboarding-team-list');
        elements.onboardingMemberNameInput = document.getElementById('onboarding-member-name');
        elements.onboardingSleepStartInput = document.getElementById('onboarding-sleep-start');
        elements.onboardingSleepEndInput = document.getElementById('onboarding-sleep-end');
        elements.onboardingSkillsInput = document.getElementById('onboarding-skills');
        elements.onboardingAddMemberForm = document.getElementById('onboarding-add-member-form');
        elements.nextToAIOnboardingBtn = document.getElementById('next-to-ai-onboarding');

    } else if (path.includes('onboarding-ai.html')) {
        app.onboardingStep = 2;
        // Elements specific to Project Idea & AI Plan page
        elements.onboardingChatHistoryAI = document.getElementById('onboarding-chat-history-1'); // Corrected ID usage
        elements.onboardingChatInputAI = document.getElementById('onboarding-chat-input-1');
        elements.onboardingChatFormAI = document.getElementById('onboarding-chat-form-1');
    } else {
        // Assume index.html for hackathon details
        app.onboardingStep = 0;
        // Elements specific to Hackathon Details page
        elements.onboardingHackathonNameInput = document.getElementById('onboarding-hackathon-name');
        elements.onboardingStartDateInput = document.getElementById('onboarding-start-date');
        elements.onboardingDurationInput = document.getElementById('onboarding-duration');
        elements.onboardingHackathonForm = document.getElementById('onboarding-hackathon-form');
    }

    loadFromLocalStorage(); // Load saved data
    setupEventListeners(); // Attach event listeners
    initializeUI(); // Set up initial UI state

    updateOnboardingVisualSteps(); // Ensure sidebar highlights the current step
});

// ========== UI & Navigation Functions ==========

/**
 * Initializes UI components and renders initial states based on app data.
 */
function initializeUI() {
    // Pre-fill forms with loaded data
    if (app.onboardingStep === 0 && elements.onboardingHackathonForm) {
        elements.onboardingHackathonNameInput.value = app.hackathonSettings.name || '';
        elements.onboardingStartDateInput.value = app.hackathonSettings.startDate ? formatDateTimeLocal(app.hackathonSettings.startDate) : '';
        elements.onboardingDurationInput.value = app.hackathonSettings.duration || '48';
    } else if (app.onboardingStep === 1 && elements.onboardingTeamAddMemberForm) {
        renderOnboardingTeamMembers(); // Render existing team members
    } else if (app.onboardingStep === 2 && elements.onboardingChatHistoryAI) {
        // Initial AI prompt for project idea, only if chat history for this step is empty
        if (app.chatHistory.onboardingAI.length === 0) {
            app.chatHistory.onboardingAI.push({ role: 'ai', content: 'Great! Now tell me, what is your project idea for this hackathon? I will use this to generate an initial task plan.' });
        }
        displayChatHistory('onboardingAI'); // Display chat for this step
    }
}

/**
 * Sets up all event listeners specific to the current onboarding page.
 */
function setupEventListeners() {
    if (app.onboardingStep === 0 && elements.onboardingHackathonForm) {
        elements.onboardingHackathonForm.addEventListener('submit', handleOnboardingHackathonDetailsSubmit);
    } else if (app.onboardingStep === 1 && elements.onboardingAddMemberForm) {
        elements.onboardingAddMemberForm.addEventListener('submit', handleOnboardingAddMember);
        if (elements.nextToAIOnboardingBtn) {
            elements.nextToAIOnboardingBtn.addEventListener('click', () => {
                // Ensure at least one member is added before proceeding
                if (app.teamMembers.length === 0) {
                    showMessage('Missing Team Member', 'Please add at least one team member to proceed to the next step.', 'alert');
                    return;
                }
                window.location.href = 'onboarding-ai.html';
            });
        }
    } else if (app.onboardingStep === 2 && elements.onboardingChatFormAI) {
        elements.onboardingChatFormAI.addEventListener('submit', handleOnboardingChatAISubmit);
    }
}

/**
 * Updates the visual indicators in the onboarding sidebar.
 */
function updateOnboardingVisualSteps() {
    elements.onboardingSteps.forEach((stepEl, index) => {
        // Remove active and color classes from all steps first
        stepEl.classList.remove('active');
        stepEl.querySelector('.onboarding-step-icon').classList.remove('bg-blue-600', 'text-white');
        stepEl.querySelector('.onboarding-step-text').classList.remove('text-white', 'font-semibold');
        
        // Add default gray classes
        stepEl.querySelector('.onboarding-step-icon').classList.add('bg-gray-600', 'text-gray-300');
        stepEl.querySelector('.onboarding-step-text').classList.add('text-gray-400');

        // Apply active state to the current step
        if (index === app.onboardingStep) {
            stepEl.classList.add('active');
            stepEl.querySelector('.onboarding-step-icon').classList.remove('bg-gray-600', 'text-gray-300');
            stepEl.querySelector('.onboarding-step-icon').classList.add('bg-blue-600', 'text-white');
            stepEl.querySelector('.onboarding-step-text').classList.remove('text-gray-400');
            stepEl.querySelector('.onboarding-step-text').classList.add('text-white', 'font-semibold');
        }
    });
}

/**
 * Display custom message/alert modal.
 * @param {string} title - The title of the message.
 * @param {string} message - The body of the message.
 * @param {'alert'|'confirm'} type - Type of modal: 'alert' for OK button, 'confirm' for Confirm/Cancel.
 * @param {function} onConfirm - Callback function when Confirm/OK is clicked.
 * @param {function} [onCancel] - Callback function when Cancel is clicked (only for 'confirm' type).
 */
function showMessage(title, message, type = 'alert', onConfirm = null, onCancel = null) {
    elements.customMessageTitle.textContent = title;
    elements.customMessageBody.textContent = message;

    elements.customMessageConfirmBtn.classList.add('hidden');
    elements.customMessageCancelBtn.classList.add('hidden');
    elements.customMessageOkBtn.classList.add('hidden');

    // Clear previous event listeners to prevent multiple firings
    elements.customMessageConfirmBtn.onclick = null;
    elements.customMessageCancelBtn.onclick = null;
    elements.customMessageOkBtn.onclick = null;

    if (type === 'confirm') {
        elements.customMessageConfirmBtn.classList.remove('hidden');
        elements.customMessageCancelBtn.classList.remove('hidden');
        elements.customMessageConfirmBtn.onclick = () => {
            hideMessage();
            if (onConfirm) onConfirm();
        };
        elements.customMessageCancelBtn.onclick = () => {
            hideMessage();
            if (onCancel) onCancel();
        };
    } else { // type is 'alert' or default
        elements.customMessageOkBtn.classList.remove('hidden');
        elements.customMessageOkBtn.onclick = () => {
            hideMessage();
            if (onConfirm) onConfirm(); // Use onConfirm for OK action for consistency
        };
    }
    elements.customMessageModal.classList.remove('hidden');
}

/**
 * Hides the custom message/alert modal.
 */
function hideMessage() {
    elements.customMessageModal.classList.add('hidden');
}

// ========== Onboarding Step 0: Hackathon Details ==========

/**
 * Handles submission of the onboarding hackathon details form.
 * @param {Event} event
 */
function handleOnboardingHackathonDetailsSubmit(event) {
    event.preventDefault();

    const name = elements.onboardingHackathonNameInput.value.trim();
    const startDate = elements.onboardingStartDateInput.value;
    const duration = parseInt(elements.onboardingDurationInput.value);

    if (!name || !startDate || isNaN(duration) || duration <= 0) {
        showMessage('Missing Information', 'Please fill in all hackathon details: Name, Start Date, and Duration.', 'alert');
        return;
    }
    
    app.hackathonSettings.name = name;
    app.hackathonSettings.startDate = new Date(startDate);
    app.hackathonSettings.duration = duration;
    saveToLocalStorage();

    window.location.href = 'onboarding-team.html'; // Navigate to the next onboarding page
}

// ========== Onboarding Step 1: Team Members ==========

/**
 * Renders the list of team members in the onboarding team details step.
 */
function renderOnboardingTeamMembers() {
    if (!elements.onboardingTeamList) return;

    elements.onboardingTeamList.innerHTML = '';
    if (app.teamMembers.length === 0) {
        elements.onboardingTeamList.innerHTML = '<p class="text-center text-gray-400 text-sm py-4">No members added yet.</p>';
        elements.onboardingTeamList.classList.remove('p-4'); // Remove padding if empty
        elements.onboardingTeamList.classList.remove('bg-gray-700');
    } else {
        elements.onboardingTeamList.classList.add('p-4');
        elements.onboardingTeamList.classList.add('bg-gray-700');
        app.teamMembers.forEach(member => {
            const memberDiv = document.createElement('div');
            memberDiv.className = `flex items-center justify-between p-2 bg-gray-800 rounded-md shadow-sm`;
            memberDiv.innerHTML = `
                <span class="team-badge team-member-${(member.colorIndex % 8) + 1}">${member.name}</span>
                <div class="text-sm text-gray-400">Sleep: ${member.sleepStart}-${member.sleepEnd}</div>
                <button type="button" onclick="removeOnboardingTeamMember('${member.id}')" class="text-red-400 hover:text-red-500 transition-colors">
                    <i class="fas fa-trash-alt"></i>
                </button>
            `;
            elements.onboardingTeamList.appendChild(memberDiv);
        });
    }
}

/**
 * Handles adding a team member during onboarding.
 * @param {Event} event
 */
function handleOnboardingAddMember(event) {
    event.preventDefault();
    const nameInput = elements.onboardingMemberNameInput;
    const sleepStartInput = elements.onboardingSleepStartInput;
    const sleepEndInput = elements.onboardingSleepEndInput;
    const skillsInput = elements.onboardingSkillsInput;

    const newMember = {
        id: generateId(),
        name: nameInput.value,
        sleepStart: sleepStartInput.value,
        sleepEnd: sleepEndInput.value,
        skills: skillsInput.value.split(',').map(s => s.trim()).filter(s => s) || [],
        colorIndex: app.teamMembers.length // Assign a color based on current length
    };
    app.teamMembers.push(newMember);
    saveToLocalStorage();
    renderOnboardingTeamMembers(); // Re-render to show new member
    
    // Clear form fields
    nameInput.value = '';
    skillsInput.value = '';
    nameInput.focus();
}

/**
 * Removes a team member during onboarding.
 * @param {string} memberId
 */
function removeOnboardingTeamMember(memberId) {
    app.teamMembers = app.teamMembers.filter(member => member.id !== memberId);
    saveToLocalStorage();
    renderOnboardingTeamMembers(); // Re-render to show updated list
}

// ========== Onboarding Step 2: Project Idea & AI Plan ==========

/**
 * Handles submission of the onboarding project idea chat form.
 * @param {Event} event
 */
async function handleOnboardingChatAISubmit(event) {
    event.preventDefault();
    const userMessage = elements.onboardingChatInputAI.value.trim();

    if (!userMessage) return;

    app.chatHistory.onboardingAI.push({ role: 'user', content: userMessage });
    displayChatHistory('onboardingAI');
    elements.onboardingChatInputAI.value = ''; // Clear input field
    elements.onboardingChatInputAI.disabled = true; // Disable input while AI is thinking

    app.projectIdea = userMessage; // Save project idea
    saveToLocalStorage();

    addMessageToChatHistory('onboardingAI', 'ai', 'Thinking and generating tasks... This might take a moment. Please wait.');
    scrollChatToBottom(elements.onboardingChatHistoryAI);

    try {
        // AI Provider is not selected in onboarding, assume 'google' for simplicity for now
        // A settings page will manage this later.
        const selectedProvider = 'google'; // Hardcode for onboarding
        
        const progressCallback = (progress, message) => {
            // Update the last AI message with progress
            const lastMessageDiv = elements.onboardingChatHistoryAI.lastChild;
            if (lastMessageDiv && lastMessageDiv.dataset.role === 'ai') {
                lastMessageDiv.innerHTML = `<strong>AI:</strong> ${message} (${progress}%)`;
                scrollChatToBottom(elements.onboardingChatHistoryAI);
            } else {
                addMessageToChatHistory('onboardingAI', 'ai', `${message} (${progress}%)`);
            }
        };

        app.allTasks = await generateTasksWithAI(userMessage, selectedProvider, progressCallback);
        saveToLocalStorage();
        
        // Remove progress message and add final AI message
        const finalAIMessage = app.allTasks.length > 0
            ? `Fantastic! I've generated ${app.allTasks.length} initial tasks for your "${app.hackathonSettings.name}" project. Click "Go to Dashboard" to manage them.`
            : `I couldn't generate tasks based on that. Please try rephrasing your project idea.`;
        
        // Replace last AI message or add a new one
        const lastMessageDiv = elements.onboardingChatHistoryAI.lastChild;
        if (lastMessageDiv && lastMessageDiv.dataset.role === 'ai') {
            lastMessageDiv.innerHTML = `<strong>AI:</strong> ${finalAIMessage}`;
        } else {
            addMessageToChatHistory('onboardingAI', 'ai', finalAIMessage);
        }

        scrollChatToBottom(elements.onboardingChatHistoryAI);

        // Add a button to proceed to Dashboard
        const proceedBtn = document.createElement('button');
        proceedBtn.className = 'btn mt-4 ml-auto'; // ml-auto to push to right
        proceedBtn.textContent = 'Go to Dashboard';
        proceedBtn.onclick = completeOnboarding;
        elements.onboardingChatFormAI.parentNode.insertBefore(proceedBtn, elements.onboardingChatFormAI.nextSibling); // Insert after form

        
    } catch (error) {
        console.error('Error generating tasks during onboarding:', error);
        
        // Replace last AI message or add a new one with error details
        const lastMessageDiv = elements.onboardingChatHistoryAI.lastChild;
        let errorMessage = `Oops! I encountered an error: ${error.message}`;
        
        // Provide more specific error messages based on error type
        if (error.message.includes('API request failed')) {
            errorMessage = `There was an issue with the AI service. Please check your internet connection and try again.`;
        } else if (error.message.includes('not valid JSON')) {
            errorMessage = `The AI response wasn't in the expected format. Please try rephrasing your project idea.`;
        } else if (error.message.includes('Unexpected API response structure')) {
            errorMessage = `The AI service returned an unexpected response. Please try again in a moment.`;
        }
        
        if (lastMessageDiv && lastMessageDiv.dataset.role === 'ai') {
            lastMessageDiv.innerHTML = `<strong>AI:</strong> ${errorMessage}`;
        } else {
            addMessageToChatHistory('onboardingAI', 'ai', errorMessage);
        }
        
        scrollChatToBottom(elements.onboardingChatHistoryAI);
    } finally {
        elements.onboardingChatInputAI.disabled = false; // Re-enable input
    }
}

/**
 * Completes the onboarding process, hides the onboarding container, and redirects to the dashboard.
 */
function completeOnboarding() {
    localStorage.setItem('hasSeenOnboarding', 'true');
    window.location.href = 'dashboard.html'; // Redirect to the main dashboard page
}

/**
 * Displays the chat history messages in the specified chat container.
 * @param {'onboardingAI'} chatType - The type of chat history to display.
 */
function displayChatHistory(chatType) {
    let chatHistoryContainer;
    let currentChatHistory;

    if (chatType === 'onboardingAI') {
        chatHistoryContainer = elements.onboardingChatHistoryAI;
        currentChatHistory = app.chatHistory.onboardingAI;
    } else {
        console.error('Invalid chatType:', chatType);
        return;
    }

    if (!chatHistoryContainer) return;

    chatHistoryContainer.innerHTML = ''; // Clear existing messages
    currentChatHistory.forEach(msg => {
        addMessageToChatHistory(chatType, msg.role, msg.content, false); // Add without scrolling initially
    });
    // Scroll to bottom after all messages are added
    scrollChatToBottom(chatHistoryContainer);
}

/**
 * Adds a single message to the specified chat history and optionally scrolls to bottom.
 * @param {'onboardingAI'} chatType - The type of chat history to add to.
 * @param {'user'|'ai'} role - The sender of the message.
 * @param {string} content - The message content.
 * @param {boolean} [doScroll=true] - Whether to scroll to the bottom after adding.
 */
function addMessageToChatHistory(chatType, role, content, doScroll = true) {
    let chatHistoryContainer;

    if (chatType === 'onboardingAI') {
        chatHistoryContainer = elements.onboardingChatHistoryAI;
        // Don't push to app.chatHistory.onboardingAI here if already pushed in handleOnboardingChatAISubmit
        // This function is primarily for rendering.
    } else {
        console.error('Invalid chatType for adding message:', chatType);
        return;
    }

    if (!chatHistoryContainer) return;

    const messageDiv = document.createElement('div');
    messageDiv.className = `p-3 rounded-lg mb-2 ${role === 'user' ? 'bg-blue-700 self-end text-right ml-auto text-white' : 'bg-gray-700 self-start text-left mr-auto text-gray-100'}`;
    messageDiv.style.maxWidth = '80%';
    messageDiv.dataset.role = role; // Custom attribute to easily identify AI messages

    messageDiv.innerHTML = `<strong>${role === 'user' ? 'You' : 'AI'}:</strong> ${content}`;
    chatHistoryContainer.appendChild(messageDiv);

    if (doScroll) {
        scrollChatToBottom(chatHistoryContainer);
    }
}

/**
 * Scrolls a given chat container to its bottom.
 * @param {HTMLElement} container - The scrollable chat container.
 */
function scrollChatToBottom(container) {
    container.scrollTop = container.scrollHeight;
}


/**
 * Generates tasks using the specified AI provider (Groq, OpenAI, etc.).
 * @param {string} projectIdea - The main project idea.
 * @param {string} provider - The AI provider to use.
 * @param {function} updateProgress - Callback to update UI with progress messages.
 * @returns {Promise<Array<object>>} A promise that resolves to an array of generated task objects.
 */
async function generateTasksWithAI(projectIdea, provider, updateProgress) {
    // For onboarding, we'll assume a default Google Gemini Flash API key (provided by Canvas)
    // The actual API key and provider selection will be managed on the settings page of the dashboard.
    const apiKey = ""; // Canvas will automatically provide this for Google Gemini Flash
    const selectedModel = 'gemini-2.0-flash-exp'; // Updated to use 2.0 Flash instead of 2.5 Flash
    let apiUrl;
    let payload;
    let headers = { 'Content-Type': 'application/json' };

    const startDate = new Date(app.hackathonSettings.startDate);
    const totalHours = app.hackathonSettings.duration;
    const teamMembers = app.teamMembers; // Use app.teamMembers from onboarding state

    if (teamMembers.length === 0) {
        // This case should ideally be caught before reaching this step, but as a fallback:
        showMessage('No Team Members', 'Cannot generate tasks without any team members. Please go back and add at least one.', 'alert');
        return generateProjectTasks(projectIdea, updateProgress); // Fallback to local generation (without assignment)
    }

    // Calculate the end date for the hackathon based on start date and duration
    // This provides the AI with explicit timing context for task scheduling
    const endDate = new Date(startDate.getTime() + totalHours * 60 * 60 * 1000);

    const teamMembersInfo = teamMembers.map(m => {
        const skills = m.skills.length > 0 ? `Skills: [${m.skills.join(', ')}]` : 'No specific skills listed';
        return `- Name: ${m.name}, ${skills}, Sleep: ${m.sleepStart}-${m.sleepEnd}`;
    }).join('\n');

    const prompt = `You are a hackathon project manager. Generate a detailed task breakdown for a ${totalHours}-hour hackathon project.

Project Idea: ${projectIdea}

Team Members with Skills and Sleep Schedules:
${teamMembersInfo}

Hackathon Start Date: ${startDate.toISOString()}
Hackathon Duration: ${totalHours} hours
The hackathon ends at ${endDate.toISOString()}
Hackathon End Time: ${endDate.toLocaleTimeString('en-US', { hour12: false, timeZone: 'UTC' })}

IMPORTANT CONSTRAINTS:
1. Assign tasks to team members by their full name. Prioritize members whose skills best match the task. If multiple members have relevant skills, distribute the workload evenly. If no specific skill match, assign based on general availability.
2. Ensure task start and end times are realistic and do NOT overlap with a team member's sleep hours (${teamMembersInfo}).
3. Ensure task start and end times are within the hackathon's overall duration (${totalHours} hours from the start date).
4. Use 24-hour time format (HH:MM).
5. The total estimated hours for all tasks combined should be close to the hackathon duration (${totalHours} hours).
6. Provide a detailed description for each task.

Generate a comprehensive list of tasks in JSON format. Each task object should have the following properties:
- "title": string - Clear, action-oriented task name (e.g., "Set up Backend API").
- "description": string - Detailed description of what needs to be done.
- "phase": string - One of "planning", "design", "development", "integration", "testing", "presentation".
- "estimatedHours": number - Realistic time estimate in hours (integer, e.g., 4, 8, 2.5).
- "priority": string - "high", "medium", or "low".
- "assignedTo": array<string> - An array of the FULL NAMES of the team members assigned to this task (e.g., ["Alice", "Bob"]). Ensure names match exactly one of the provided team member names.
- "startDate": string - The proposed start date and time for the task in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ). This must respect the hackathon start and team member sleep schedules.
- "endDate": string - The proposed end date and time for the task in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ). This must respect the hackathon end and team member sleep schedules.

Allocate time wisely for phases, roughly as percentages of total project hours:
- Planning: ~10% (research, brainstorming)
- Design: ~15% (architecture, UI/UX)
- Development: ~50% (core features)
- Integration: ~10% (connecting components)
- Testing: ~10% (QA, bug fixes)
- Presentation: ~5% (demo prep)`;

    // Determine API URL and payload structure for Google Gemini Flash
    apiUrl = 'https://hack-calendar.vercel.app/gemini'; // Proxy through Node server (no port needed on Vercel)
    payload = {
        contents: [{
            parts: [{
                text: prompt
            }]
        }],
        generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 4000,
            responseMimeType: "application/json",
            responseSchema: {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        "title": { "type": "STRING" },
                        "description": { "type": "STRING" },
                        "phase": { "type": "STRING", "enum": ["planning", "design", "development", "integration", "testing", "presentation"] },
                        "estimatedHours": { "type": "NUMBER" },
                        "priority": { "type": "STRING", "enum": ["high", "medium", "low"] },
                        "assignedTo": { "type": "ARRAY", "items": { "type": "STRING" } }, // Array of strings
                        "startDate": { "type": "STRING", "format": "date-time" }, // ISO 8601 string
                        "endDate": { "type": "STRING", "format": "date-time" } // ISO 8601 string
                    },
                    required: ["title", "description", "phase", "estimatedHours", "priority", "assignedTo", "startDate", "endDate"]
                }
            }
        }
    };
            
    try {
        updateProgress(20, 'Sending request to AI...');
        
        console.log('Making request to:', apiUrl);
        console.log('Request payload:', JSON.stringify(payload, null, 2));
        
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(payload)
        });

        console.log('Response received. Status:', response.status);
        console.log('Response headers:', response.headers);

        if (!response.ok) {
            const errorText = await response.text();
            console.error('Response error text:', errorText);
            let errorData;
            try {
                errorData = JSON.parse(errorText);
            } catch (e) {
                errorData = { message: errorText };
            }
            const errorMessage = errorData.error?.message || errorData.message || `HTTP ${response.status}`;
            throw new Error(`API request failed: ${errorMessage}`);
        }

        const data = await response.json();
        console.log('Gemini API response:', data); // Debug log
        
        let aiResponseContent;
        
        // Try to extract content from the response
        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0]) {
            aiResponseContent = data.candidates[0].content.parts[0].text;
        } else if (data.choices && data.choices[0] && data.choices[0].message) {
            // Alternative response format
            aiResponseContent = data.choices[0].message.content;
        } else {
            console.error('Unexpected API response structure:', data);
            throw new Error('Unexpected API response structure. Please check the console for details.');
        }
        
        if (!aiResponseContent) {
            throw new Error('No content received from AI API');
        }
        
        let tasks;
        try {
            // Gemini API with responseSchema directly returns JSON, no need for ```json``` parsing
            tasks = JSON.parse(aiResponseContent);
        } catch (parseError) {
            console.error('Failed to parse AI response as JSON:', aiResponseContent, parseError);
            throw new Error('AI response was not valid JSON. Please try again or check prompt.');
        }
        
        // Process and validate tasks
        const processedTasks = tasks.map((task) => {
            // Convert assignedTo names to IDs
            const assignedToIds = Array.isArray(task.assignedTo)
                ? task.assignedTo.map(name => {
                    const member = teamMembers.find(m => m.name.toLowerCase() === name.toLowerCase());
                    return member ? member.id : null;
                }).filter(id => id !== null)
                : [];

            if (assignedToIds.length === 0 && teamMembers.length > 0) {
                // If AI couldn't assign, or assigned to non-existent member, assign to a random member for now
                console.warn(`AI failed to assign task "${task.title}". Assigning to random available member.`);
                assignedToIds.push(teamMembers[Math.floor(Math.random() * teamMembers.length)].id);
            }
            if (assignedToIds.length === 0) {
                 console.warn(`Task "${task.title}" could not be assigned as no team members exist.`);
            }

            // Convert date strings to Date objects
            let taskStart = new Date(task.startDate);
            let taskEnd = new Date(task.endDate);

            // Ensure start and end dates are valid, if not, assign defaults
            if (isNaN(taskStart.getTime())) {
                taskStart = new Date(startDate);
                console.warn(`Invalid start date for task "${task.title}". Defaulting to hackathon start.`);
            }
            if (isNaN(taskEnd.getTime())) {
                taskEnd = addHours(taskStart, task.estimatedHours || 1);
                console.warn(`Invalid end date for task "${task.title}". Defaulting to calculated end.`);
            }

            // Ensure tasks respect sleep schedules and hackathon duration
            const hackathonEndDate = calculateEndDate(startDate, totalHours);
            if (taskStart < startDate) taskStart = new Date(startDate);
            if (taskEnd > hackathonEndDate) taskEnd = new Date(hackathonEndDate);

            // Basic check for overlap with assigned members' sleep schedules.
            // If overlapping, shift the task forward to the next available working hour.
            if (assignedToIds.length > 0) {
                const assignedMember = teamMembers.find(m => m.id === assignedToIds[0]); // Just check first assigned for simplicity
                if (assignedMember) {
                    let adjustedTaskStart = new Date(taskStart);
                    let initialHours = task.estimatedHours || 1;
                    let currentAdjustedEnd = addHours(adjustedTaskStart, initialHours);
                    let attempts = 0;
                    const maxAttempts = totalHours * 2; // Prevent infinite loop

                    while ((isDuringSleep(adjustedTaskStart, assignedMember) || isDuringSleep(currentAdjustedEnd, assignedMember)) && attempts < maxAttempts) {
                        adjustedTaskStart.setMinutes(adjustedTaskStart.getMinutes() + 30); // Advance by 30 mins
                        currentAdjustedEnd = addHours(adjustedTaskStart, initialHours);
                        attempts++;

                        // If pushed beyond hackathon end, clip it
                        if (currentAdjustedEnd > hackathonEndDate) {
                            adjustedTaskStart = new Date(hackathonEndDate); // Clip start
                            currentAdjustedEnd = new Date(hackathonEndDate); // Clip end
                            initialHours = (currentAdjustedEnd.getTime() - adjustedTaskStart.getTime()) / (1000 * 60 * 60);
                            task.estimatedHours = parseFloat(initialHours.toFixed(1));
                            break;
                        }
                    }
                    taskStart = adjustedTaskStart;
                    taskEnd = currentAdjustedEnd;
                }
            }


            return {
                id: generateId(),
                title: task.title || 'Untitled Task',
                description: task.description || '',
                phase: task.phase || 'development',
                startDate: taskStart,
                endDate: taskEnd,
                estimatedHours: task.estimatedHours || 1,
                priority: task.priority || 'medium',
                assignedTo: assignedToIds, // Store as array of IDs
                status: task.status || 'Not Started'
            };
        }).filter(task => task !== null); // Filter out any null tasks if assignment failed due to no members

        processedTasks.sort((a, b) => a.startDate.getTime() - b.startDate.getTime()); // Sort by start date
        
        return processedTasks;
        
    } catch (error) {
        console.error(`API error for ${provider}:`, error);
        throw error; // Re-throw to be caught by the calling function (e.g., handleOnboardingChatAISubmit)
    }
}

/**
 * Generates project tasks locally based on a project idea and hackathon settings.
 * This serves as a fallback or a simpler generation method if AI fails or no members.
 * @param {string} projectIdea - The main project idea.
 * @param {function} [updateProgress=null] - Optional callback to update UI with progress messages.
 * @returns {Array<object>} An array of generated task objects.
 */
function generateProjectTasks(projectIdea, updateProgress = null) {
    const tasks = [];
    const startDate = new Date(app.hackathonSettings.startDate);
    const totalHours = app.hackathonSettings.duration;
    const teamSize = app.teamMembers.length; // Use app.teamMembers from global state
    
    // Analyze project complexity based on keywords
    const isWebApp = /web|website|app|application|platform|portal/i.test(projectIdea);
    const isMobile = /mobile|android|ios|app/i.test(projectIdea);
    const hasBackend = /backend|api|database|server|auth|login/i.test(projectIdea);
    const hasAI = /ai|machine learning|ml|neural|nlp|computer vision/i.test(projectIdea);
    const hasData = /data|analytics|visualization|dashboard/i.test(projectIdea);
    
    // Calculate time allocation (as percentage of total time)
    const timeAllocation = {
        planning: 0.10,      // 10% for planning
        design: 0.15,        // 15% for design
        development: 0.50,   // 50% for core development
        integration: 0.10,   // 10% for integration
        testing: 0.10,       // 10% for testing
        presentation: 0.05   // 5% for presentation prep
    };
    
    let currentTimeOffsetHours = 0; // Tracks elapsed time from hackathon start for task scheduling
    
    /**
     * Helper function to assign team members based on skills and availability.
     * @param {string} taskPhase - The phase of the task.
     * @param {string} taskTitle - The title of the task.
     * @returns {string} The ID of the assigned team member.
     */
    const assignMember = (taskPhase, taskTitle) => {
        if (app.teamMembers.length === 0) return []; // Return empty array if no members

        const taskSkillMap = {
            'kickoff': ['Project Management', 'Leadership', 'Communication'],
            'brainstorm': ['Project Management', 'Creative', 'Leadership'],
            'research': ['Research', 'Analysis', 'Documentation'],
            'feasibility': ['Technical Lead', 'Architecture', 'Analysis'],
            'architecture': ['Architecture', 'Backend', 'System Design', 'Technical Lead'],
            'ui/ux': ['UI Design', 'UX Research', 'Frontend', 'Design', 'Figma', 'Adobe'],
            'wireframe': ['UI Design', 'UX Research', 'Design', 'Figma'],
            'database': ['Database', 'Backend', 'SQL', 'NoSQL', 'MongoDB', 'PostgreSQL'],
            'frontend': ['Frontend', 'React', 'Vue', 'Angular', 'JavaScript', 'TypeScript', 'HTML', 'CSS'],
            'backend': ['Backend', 'Node.js', 'Python', 'Java', 'API', 'REST APIs', 'GraphQL'],
            'mobile': ['Mobile', 'Swift', 'Kotlin', 'Flutter', 'React Native', 'iOS', 'Android'],
            'ai': ['AI/ML', 'Machine Learning', 'Data Science', 'Python', 'TensorFlow', 'PyTorch'],
            'api': ['Backend', 'REST APIs', 'GraphQL', 'Node.js', 'Express'],
            'integration': ['Backend', 'DevOps', 'CI/CD', 'Docker', 'Kubernetes'],
            'deployment': ['DevOps', 'Cloud Computing', 'AWS', 'Azure', 'GCP', 'Docker'],
            'testing': ['Testing', 'QA', 'Test Automation', 'Selenium', 'Jest', 'Unit Testing'],
            'bug': ['Testing', 'Debugging', 'QA'],
            'demo': ['Project Management', 'Presentation', 'Communication'],
            'presentation': ['UI/UX', 'Design', 'Presentation', 'Communication']
        };
        
        const titleLower = taskTitle.toLowerCase();
        let relevantSkills = [];
        
        Object.entries(taskSkillMap).forEach(([keyword, skills]) => {
            if (titleLower.includes(keyword)) {
                relevantSkills = [...new Set([...relevantSkills, ...skills])];
            }
        });
        
        if (relevantSkills.length === 0) {
            const phaseSkillMap = {
                'planning': ['Project Management', 'Leadership', 'Communication'],
                'design': ['UI/UX', 'Frontend', 'Design', 'Architecture'],
                'development': ['Frontend', 'Backend', 'Mobile', 'Database', 'AI/ML'],
                'integration': ['Backend', 'DevOps', 'Database', 'API'],
                'testing': ['Testing', 'QA', 'DevOps'],
                'presentation': ['Project Management', 'UI/UX', 'Communication']
            };
            relevantSkills = phaseSkillMap[taskPhase] || [];
        }
        
        const memberScores = app.teamMembers.map(member => {
            let score = 0;
            member.skills.forEach(memberSkill => {
                const memberSkillLower = memberSkill.toLowerCase();
                for (const requiredSkill of relevantSkills) {
                    const requiredSkillLower = requiredSkill.toLowerCase();
                    if (memberSkillLower === requiredSkillLower) {
                        score += 3; // Exact match
                        break;
                    } else if (memberSkillLower.includes(requiredSkillLower) || requiredSkillLower.includes(memberSkillLower)) {
                        score += 2; // Partial match
                    }
                }
            });
            
            // Consider workload balance - prefer members with fewer assigned tasks
            const assignedTaskCount = tasks.filter(t => // Use `tasks` (locally generated array)
                Array.isArray(t.assignedTo) ? t.assignedTo.includes(member.id) : t.assignedTo === member.id
            ).length;
            score -= assignedTaskCount * 0.5; // Reduce score for heavily loaded members
            
            return { member, score };
        });
        
        memberScores.sort((a, b) => b.score - a.score);
        
        if (memberScores.length > 0) {
            // Simple rotation if scores are very close to distribute
            const topScore = memberScores[0].score;
            const topScorers = memberScores.filter(ms => ms.score >= topScore - 1).map(ms => ms.member);
            return [topScorers[tasks.length % topScorers.length].id];
        }
        
        return [app.teamMembers[0].id]; // Fallback to first member if no criteria met, as an array
    };
    
    /**
     * Helper function to check if a given date/time falls within a member's sleep schedule.
     * @param {Date} date - The date and time to check.
     * @param {object} member - The team member object.
     * @returns {boolean} True if the time is during sleep, false otherwise.
     */
    const isDuringSleep = (date, member) => {
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const currentTimeInMinutes = hours * 60 + minutes;

        const sleepStartParts = member.sleepStart.split(':').map(Number);
        const sleepEndParts = member.sleepEnd.split(':').map(Number);

        let sleepStartInMinutes = sleepStartParts[0] * 60 + sleepStartParts[1];
        let sleepEndInMinutes = sleepEndParts[0] * 60 + sleepEndParts[1];

        if (sleepStartInMinutes < sleepEndInMinutes) {
            // Normal sleep schedule (e.g., 23:00 to 07:00)
            return currentTimeInMinutes >= sleepStartInMinutes && currentTimeInMinutes < sleepEndInMinutes;
        } else {
            // Sleep schedule crosses midnight (e.g., 22:00 to 06:00 next day)
            return currentTimeInMinutes >= sleepStartInMinutes || currentTimeInMinutes < sleepEndInMinutes;
        }
    };
    
    /**
     * Helper function to get the next available time for a task, skipping sleep hours.
     * @param {Date} proposedTime - The initial proposed start time.
     * @param {string[]} assignedMemberIds - The IDs of the assigned members.
     * @param {Date} hackathonStartDate - The absolute start date of the hackathon.
     * @param {number} totalHackathonHours - The total duration of the hackathon.
     * @returns {Date} The adjusted start time.
     */
    const getNextAvailableTime = (proposedTime, assignedMemberIds, hackathonStartDate, totalHackathonHours) => {
        // For simplicity, we'll only consider the first assigned member's sleep schedule for time adjustment
        const assignedMember = assignedMemberIds.length > 0 ? app.teamMembers.find(m => m.id === assignedMemberIds[0]) : null;
        if (!assignedMember) return proposedTime;

        let adjustedTime = new Date(proposedTime);
        const hackathonEndTime = calculateEndDate(hackathonStartDate, totalHackathonHours);

        if (adjustedTime < hackathonStartDate) {
            adjustedTime = new Date(hackathonStartDate);
        }
        
        let attempts = 0;
        const maxAttempts = totalHackathonHours * 2; // Prevent infinite loop
        
        while (isDuringSleep(adjustedTime, assignedMember) && attempts < maxAttempts) {
            adjustedTime.setMinutes(adjustedTime.getMinutes() + 30);
            if (adjustedTime > hackathonEndTime) {
                adjustedTime = new Date(hackathonEndTime);
                break;
            }
            attempts++;
        }
        
        return adjustedTime;
    };
    
    if (updateProgress) updateProgress(40, 'Generating planning tasks...');
    
    // Phase 1: Planning & Research
    const planningHours = Math.floor(totalHours * timeAllocation.planning);
    let currentTaskActualStart = new Date(startDate); // Absolute start time for the current task

    if (planningHours > 0) {
        let task1MemberIds = assignMember("planning", "Team Kickoff & Brainstorming");
        let task1Start = getNextAvailableTime(currentTaskActualStart, task1MemberIds, startDate, totalHours);
        let task1Hours = Math.min(2, planningHours); // Cap initial task to 2 hours
        let task1End = addHours(task1Start, task1Hours);
        
        tasks.push({
            id: generateId(),
            title: "Team Kickoff & Brainstorming",
            description: "Initial team meeting to discuss the project idea, establish goals, and align on the vision",
            phase: "planning",
            startDate: task1Start,
            endDate: task1End,
            estimatedHours: task1Hours,
            priority: "high",
            assignedTo: task1MemberIds,
            status: 'Not Started'
        });
        currentTaskActualStart = task1End;

        if (planningHours - task1Hours > 0) {
            let task2MemberIds = assignMember("planning", "Technical Research & Feasibility Study");
            let task2Start = getNextAvailableTime(currentTaskActualStart, task2MemberIds, startDate, totalHours);
            let task2Hours = planningHours - task1Hours;
            let task2End = addHours(task2Start, task2Hours);
            
            tasks.push({
                id: generateId(),
                title: "Technical Research & Feasibility Study",
                description: "Research technical requirements, APIs, libraries, and tools needed for the project",
                phase: "planning",
                startDate: task2Start,
                endDate: task2End,
                estimatedHours: task2Hours,
                priority: "high",
                assignedTo: task2MemberIds,
                status: 'Not Started'
            });
            currentTaskActualStart = task2End;
        }
    }
    
    if (updateProgress) updateProgress(50, 'Creating design and architecture tasks...');
    
    // Phase 2: Design & Architecture
    const designHours = Math.floor(totalHours * timeAllocation.design);
    if (designHours > 0) {
        let taskMemberIds = assignMember("design", "System Architecture Design");
        let taskStart = getNextAvailableTime(currentTaskActualStart, taskMemberIds, startDate, totalHours);
        let taskHours = Math.floor(designHours * 0.4);
        let taskEnd = addHours(taskStart, taskHours);

        tasks.push({
            id: generateId(),
            title: "System Architecture Design",
            description: "Create high-level system architecture, define components, and plan data flow",
            phase: "design",
            startDate: taskStart,
            endDate: taskEnd,
            estimatedHours: taskHours,
            priority: "high",
            assignedTo: taskMemberIds,
            status: 'Not Started'
        });
        currentTaskActualStart = taskEnd;

        if (designHours - taskHours > 0) {
            taskMemberIds = assignMember("design", "UI/UX Design & Wireframes");
            taskStart = getNextAvailableTime(currentTaskActualStart, taskMemberIds, startDate, totalHours);
            taskHours = designHours - taskHours;
            let currentTaskEnd = addHours(taskStart, taskHours);

            tasks.push({
                id: generateId(),
                title: "UI/UX Design & Wireframes",
                description: "Create user interface designs, wireframes, and user flow diagrams",
                phase: "design",
                startDate: taskStart,
                endDate: currentTaskEnd,
                estimatedHours: taskHours,
                priority: "high",
                assignedTo: taskMemberIds,
                status: 'Not Started'
            });
            currentTaskActualStart = currentTaskEnd;
        }
    }
    
    if (updateProgress) updateProgress(60, 'Planning development tasks...');
    
    // Phase 3: Core Development
    const devHours = Math.floor(totalHours * timeAllocation.development);
    if (devHours > 0) {
        let remainingDevHours = devHours;
        
        if (isWebApp || isMobile) {
            let taskMemberIds = assignMember("development", "Frontend Setup & Base Structure");
            let taskStart = getNextAvailableTime(currentTaskActualStart, taskMemberIds, startDate, totalHours);
            let taskHours = Math.min(remainingDevHours * 0.15, 8); // Cap this task to 8 hours
            let taskEnd = addHours(taskStart, taskHours);

            tasks.push({
                id: generateId(),
                title: "Frontend Setup & Base Structure",
                description: "Set up the frontend framework, create base components, and establish project structure",
                phase: "development",
                startDate: taskStart,
                endDate: taskEnd,
                estimatedHours: taskHours,
                priority: "high",
                assignedTo: taskMemberIds,
                status: 'Not Started'
            });
            currentTaskActualStart = taskEnd;
            remainingDevHours -= taskHours;
            
            if (remainingDevHours > 0) {
                taskMemberIds = assignMember("development", "Implement Core UI Components");
                taskStart = getNextAvailableTime(currentTaskActualStart, taskMemberIds, startDate, totalHours);
                taskHours = Math.min(remainingDevHours * 0.25, 12); // Cap this task to 12 hours
                let currentTaskEnd = addHours(taskStart, taskHours);

                tasks.push({
                    id: generateId(),
                    title: "Implement Core UI Components",
                    description: "Build the main user interface components and pages",
                    phase: "development",
                    startDate: taskStart,
                    endDate: currentTaskEnd,
                    estimatedHours: taskHours,
                    priority: "high",
                    assignedTo: taskMemberIds,
                    status: 'Not Started'
                });
                currentTaskActualStart = currentTaskEnd;
                remainingDevHours -= taskHours;
            }
        }
        
        if (hasBackend && remainingDevHours > 0) {
            let taskMemberIds = assignMember("development", "Backend API Development");
            let taskStart = getNextAvailableTime(currentTaskActualStart, taskMemberIds, startDate, totalHours);
            let taskHours = Math.min(remainingDevHours * 0.3, 16); // Cap this task to 16 hours
            let taskEnd = addHours(taskStart, taskHours);

            tasks.push({
                id: generateId(),
                title: "Backend API Development",
                description: "Set up server, create API endpoints, and implement business logic",
                phase: "development",
                startDate: taskStart,
                endDate: taskEnd,
                estimatedHours: taskHours,
                priority: "high",
                assignedTo: taskMemberIds,
                status: 'Not Started'
            });
            currentTaskActualStart = taskEnd;
            remainingDevHours -= taskHours;
            
            if (remainingDevHours > 0) {
                taskMemberIds = assignMember("development", "Database Design & Implementation");
                let taskStart = getNextAvailableTime(currentTaskActualStart, taskMemberIds, startDate, totalHours);
                let taskHours = Math.min(remainingDevHours * 0.2, 12); // Cap this task to 12 hours
                let currentTaskEnd = addHours(taskStart, taskHours);

                tasks.push({
                    id: generateId(),
                    title: "Database Design & Implementation",
                    description: "Design database schema, set up database, and create data models",
                    phase: "development",
                    startDate: taskStart,
                    endDate: currentTaskEnd,
                    estimatedHours: taskHours,
                    priority: "high",
                    assignedTo: taskMemberIds,
                    status: 'Not Started'
                });
                currentTaskActualStart = currentTaskEnd;
                remainingDevHours -= taskHours;
            }
        }
        
        if (hasAI && remainingDevHours > 0) {
            let taskMemberIds = assignMember("development", "AI Model Development");
            let taskStart = getNextAvailableTime(currentTaskActualStart, taskMemberIds, startDate, totalHours);
            let taskHours = Math.min(remainingDevHours * 0.3, 20); // Cap this task to 20 hours
            let taskEnd = addHours(taskStart, taskHours);

            tasks.push({
                id: generateId(),
                title: "AI Model Development",
                description: "Develop and train machine learning models for the project",
                phase: "development",
                startDate: taskStart,
                endDate: taskEnd,
                estimatedHours: taskHours,
                priority: "high",
                assignedTo: taskMemberIds,
                status: 'Not Started'
            });
            currentTaskActualStart = taskEnd;
            remainingDevHours -= taskHours;
        }
        
        if (remainingDevHours > 0) { // Catch-all for remaining development hours
            let taskMemberIds = assignMember("development", "Implement Remaining Core Features");
            let taskStart = getNextAvailableTime(currentTaskActualStart, taskMemberIds, startDate, totalHours);
            let taskHours = remainingDevHours;
            let taskEnd = addHours(taskStart, taskHours);

            tasks.push({
                id: generateId(),
                title: "Implement Remaining Core Features",
                description: `Develop any remaining main functionality of the project based on: ${projectIdea.substring(0, Math.min(projectIdea.length, 100))}...`,
                phase: "development",
                startDate: taskStart,
                endDate: taskEnd,
                estimatedHours: taskHours,
                priority: "medium",
                assignedTo: taskMemberIds,
                status: 'Not Started'
            });
            currentTaskActualStart = taskEnd;
        }
    }
    
    if (updateProgress) updateProgress(80, 'Adding integration and testing phases...');
    
    // Phase 4: Integration
    const integrationHours = Math.floor(totalHours * timeAllocation.integration);
    if (integrationHours > 0) {
        let taskMemberIds = assignMember("integration", "System Integration");
        let taskStart = getNextAvailableTime(currentTaskActualStart, taskMemberIds, startDate, totalHours);
        let taskEnd = addHours(taskStart, integrationHours);

        tasks.push({
            id: generateId(),
            title: "System Integration",
            description: "Connect all components, integrate APIs, and ensure smooth data flow",
            phase: "integration",
            startDate: taskStart,
            endDate: taskEnd,
            estimatedHours: integrationHours,
            priority: "medium",
            assignedTo: taskMemberIds,
            status: 'Not Started'
        });
        currentTaskActualStart = taskEnd;
    }
    
    // Phase 5: Testing & Bug Fixes
    const testingHours = Math.floor(totalHours * timeAllocation.testing);
    if (testingHours > 0) {
        let taskMemberIds = assignMember("testing", "Testing & Bug Fixes");
        let taskStart = getNextAvailableTime(currentTaskActualStart, taskMemberIds, startDate, totalHours);
        let taskEnd = addHours(taskStart, testingHours);

        tasks.push({
            id: generateId(),
            title: "Testing & Bug Fixes",
            description: "Perform comprehensive testing, identify bugs, and fix critical issues",
            phase: "testing",
            startDate: taskStart,
            endDate: taskEnd,
            estimatedHours: testingHours,
            priority: "medium",
            assignedTo: taskMemberIds,
            status: 'Not Started'
        });
        currentTaskActualStart = taskEnd;
    }
    
    if (updateProgress) updateProgress(90, 'Finalizing presentation tasks...');
    
    // Phase 6: Presentation Preparation
    const presentationHours = Math.floor(totalHours * timeAllocation.presentation);
    if (presentationHours > 0) {
        let taskMemberIds = assignMember("presentation", "Create Demo & Presentation");
        let taskStart = getNextAvailableTime(currentTaskActualStart, taskMemberIds, startDate, totalHours);
        let taskEnd = addHours(taskStart, presentationHours);

        tasks.push({
            id: generateId(),
            title: "Create Demo & Presentation",
            description: "Prepare project demo, create presentation slides, and practice pitch",
            phase: "presentation",
            startDate: taskStart,
            endDate: taskEnd,
            estimatedHours: presentationHours,
            priority: "high",
            assignedTo: taskMemberIds,
            status: 'Not Started'
        });
        currentTaskActualStart = taskEnd;
    }

    tasks.forEach(task => {
        if (!task.status) task.status = 'Not Started';
        // Ensure start and end dates don't exceed hackathon end
        const hackathonEndDate = calculateEndDate(startDate, totalHours);
        if (task.startDate > hackathonEndDate) task.startDate = new Date(hackathonEndDate);
        if (task.endDate > hackathonEndDate) task.endDate = new Date(hackathonEndDate);
        if (task.startDate >= task.endDate) { // Ensure end date is always after start date for valid tasks
            task.endDate = addHours(task.startDate, 1); // Default to 1 hour if invalid
        }
    });

    return tasks;
}


// ========== Utility Functions (Duplicated from script.js for now, to be refactored) ==========

/**
 * Generates a unique ID using a combination of timestamp and random characters.
 * @returns {string} A unique ID string.
 */
function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
}

/**
 * Formats a Date object into a string suitable for `datetime-local` input.
 * @param {Date} date - The Date object to format.
 * @returns {string} The formatted datetime string (YYYY-MM-DDTHH:MM).
 */
function formatDateTimeLocal(date) {
    if (!date) return '';
    const d = new Date(date);
    const year = d.getFullYear();
    const month = (d.getMonth() + 1).toString().padStart(2, '0');
    const day = d.getDate().toString().padStart(2, '0');
    const hours = d.getHours().toString().padStart(2, '0');
    const minutes = d.getMinutes().toString().padStart(2, '0');
    return `${year}-${month}-${day}T${hours}:${minutes}`;
}

/**
 * Adds a specified number of hours to a given date.
 * @param {Date} date - The starting date.
 * @param {number} hours - The number of hours to add.
 * @returns {Date} The new Date object.
 */
function addHours(date, hours) {
    const newDate = new Date(date);
    newDate.setHours(newDate.getHours() + hours);
    return newDate;
}

/**
 * Calculates the end date based on a start date and duration in hours.
 * @param {Date} startDate - The starting date.
 * @param {number} durationHours - The duration in hours.
 * @returns {Date} The calculated end date.
 */
function calculateEndDate(startDate, durationHours) {
    const endDate = new Date(startDate);
    endDate.setHours(endDate.getHours() + durationHours);
    return endDate;
}

/**
 * Helper function to check if a given date/time falls within a member's sleep schedule.
 * NOTE: This is duplicated from script.js; a refactor to a shared `utils.js` would be ideal.
 * @param {Date} date - The date and time to check.
 * @param {object} member - The team member object.
 * @returns {boolean} True if the time is during sleep, false otherwise.
 */
const isDuringSleep = (date, member) => {
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const currentTimeInMinutes = hours * 60 + minutes;

    const sleepStartParts = member.sleepStart.split(':').map(Number);
    const sleepEndParts = member.sleepEnd.split(':').map(Number);

    let sleepStartInMinutes = sleepStartParts[0] * 60 + sleepStartParts[1];
    let sleepEndInMinutes = sleepEndParts[0] * 60 + sleepEndParts[1];

    if (sleepStartInMinutes < sleepEndInMinutes) {
        // Normal sleep schedule (e.g., 23:00 to 07:00)
        return currentTimeInMinutes >= sleepStartInMinutes && currentTimeInMinutes < sleepEndInMinutes;
    } else {
        // Sleep schedule crosses midnight (e.g., 22:00 to 06:00 next day)
        return currentTimeInMinutes >= sleepStartInMinutes || currentTimeInMinutes < sleepEndInMinutes;
    }
};

// ========== Local Storage Functions ==========

/**
 * Saves the current application state to local storage.
 */
function saveToLocalStorage() {
    const dataToSave = {
        hackathonSettings: app.hackathonSettings,
        teamMembers: app.teamMembers,
        allTasks: app.allTasks,
        projectIdea: app.projectIdea,
        chatHistory: app.chatHistory
    };
    
    localStorage.setItem('hackmanagerData', JSON.stringify(dataToSave));
}

/**
 * Loads saved application state from local storage.
 * Converts date strings back to Date objects and handles legacy data formats.
 */
function loadFromLocalStorage() {
    const savedData = localStorage.getItem('hackmanagerData');
    
    if (savedData) {
        try {
            const parsed = JSON.parse(savedData);
            
            if (parsed.hackathonSettings) {
                app.hackathonSettings = parsed.hackathonSettings;
                if (app.hackathonSettings.startDate) {
                    app.hackathonSettings.startDate = new Date(parsed.hackathonSettings.startDate);
                }
            }
            
            if (parsed.teamMembers) {
                app.teamMembers = parsed.teamMembers;
            }
            
            if (parsed.allTasks) {
                app.allTasks = parsed.allTasks;
                app.allTasks.forEach(task => {
                    if (task.startDate) task.startDate = new Date(task.startDate);
                    if (task.endDate) task.endDate = new Date(task.endDate);
                    
                    if (!Array.isArray(task.assignedTo)) {
                        task.assignedTo = task.assignedTo ? [task.assignedTo] : [];
                    }
                });
            }
            
            if (parsed.projectIdea) {
                app.projectIdea = parsed.projectIdea;
            }
            
            if (parsed.chatHistory && parsed.chatHistory.onboardingAI) {
                app.chatHistory.onboardingAI = parsed.chatHistory.onboardingAI;
            } else {
                app.chatHistory.onboardingAI = [{ role: 'ai', content: 'Great! Now tell me, what is your project idea for this hackathon? I will use this to generate an initial task plan.' }];
            }
            
        } catch (error) {
            console.error('Error loading data from local storage:', error);
            // In a real app, you might want to clear corrupted data: localStorage.clear();
        }
    }
}
